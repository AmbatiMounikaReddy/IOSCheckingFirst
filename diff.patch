diff --git a/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefault.m b/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefault.m
index 0bb6c5c59..5174a1463 100644
--- a/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefault.m
+++ b/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefault.m
@@ -16,9 +16,9 @@
 #import "MSUtility+StringFormatting.h"
 
 /**
- * Minimum flush interval for channel.
+ * Timestamp of the oldest log that was added.
  */
-static NSUInteger const kMSFlushIntervalMinimum = 3;
+static NSString *kMSStartTimer = @"MSChannelStartTimer";
 
 @implementation MSChannelUnitDefault
 
@@ -245,6 +245,8 @@ - (void)sendLogContainer:(MSLogContainer *__nonnull)container
               BOOL succeeded = response.statusCode == MSHTTPCodesNo200OK;
               if (succeeded) {
                 MSLogDebug([MSAppCenter logTag], @"Log(s) sent with success, batch Id:%@.", ingestionBatchId);
+                // Update current timestamp
+                [MS_USER_DEFAULTS setObject:[NSDate date] forKey:[self getStartTimeKey]];
 
                 // Notify delegates.
                 [self enumerateDelegatesForSelector:@selector(channel:didSucceedSendingLog:)
@@ -425,15 +427,22 @@ - (void)startTimer {
  */
 - (NSUInteger)resolveFlushInterval {
   NSUInteger flushInterval = self.configuration.flushInterval;
-  if (flushInterval > kMSFlushIntervalMinimum) {
+  if (flushInterval > kMSFlushIntervalDefault) {
     NSDate *date = [NSDate date];
-    NSDate *latestLogTime = [self.storage getOldestLogTime:self.configuration.groupId];
-    flushInterval -= (NSUInteger)[date timeIntervalSinceDate:latestLogTime];
-    return MAX(flushInterval, kMSFlushIntervalMinimum);
+    NSDate *oldestLogTime = [MS_USER_DEFAULTS objectForKey:[self getStartTimeKey]];
+    if (!oldestLogTime) {
+      [MS_USER_DEFAULTS setObject:date forKey:[self getStartTimeKey]];
+    }
+    flushInterval -= (NSUInteger)[date timeIntervalSinceDate:oldestLogTime];
+    return MIN(self.configuration.flushInterval, MAX(flushInterval, kMSFlushIntervalDefault));
   }
   return flushInterval;
 }
 
+- (NSString *)getStartTimeKey {
+  return [NSString stringWithFormat:@"%@:%@", kMSStartTimer, self.configuration.groupId];
+}
+
 - (void)resetTimer {
   if (self.timerSource) {
     dispatch_source_cancel(self.timerSource);
@@ -465,6 +474,7 @@ - (void)setEnabled:(BOOL)isEnabled andDeleteDataOnDisabled:(BOOL)deleteData {
       self.itemsCount = 0;
       self.availableBatchFromStorage = NO;
       self.pendingBatchQueueFull = NO;
+      [MS_USER_DEFAULTS removeObjectForKey:[self getStartTimeKey]];
 
       // Prevent further logs from being persisted.
       self.discardLogs = YES;
diff --git a/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefaultPrivate.h b/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefaultPrivate.h
index ed1ba818d..f7667b332 100644
--- a/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefaultPrivate.h
+++ b/AppCenter/AppCenter/Internals/Channel/MSChannelUnitDefaultPrivate.h
@@ -39,6 +39,18 @@ NS_ASSUME_NONNULL_BEGIN
  */
 - (void)resumeWithIdentifyingObjectSync:(id<NSObject>)identifyingObject;
 
+/**
+ * If we have flushInterval bigger than 3 seconds, we should subtract an oldest log's timestamp from it.
+ * It is needed to avoid situations when the logs not being sent to server cause time interval is too big
+ * for a typical user session.
+ */
+- (NSUInteger)resolveFlushInterval;
+
+/**
+ * @return Key for User Defaults file where an oldest log timestamp for this channel is stored.
+ */
+- (NSString *)getStartTimeKey;
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/AppCenter/AppCenter/Internals/Storage/MSLogDBStorage.m b/AppCenter/AppCenter/Internals/Storage/MSLogDBStorage.m
index 9e8b30437..d6b1c108a 100644
--- a/AppCenter/AppCenter/Internals/Storage/MSLogDBStorage.m
+++ b/AppCenter/AppCenter/Internals/Storage/MSLogDBStorage.m
@@ -253,20 +253,6 @@ - (void)deleteLogsWithBatchId:(NSString *)batchId groupId:(NSString *)groupId {
 
 #pragma mark - DB selection
 
-- (NSDate *)getOldestLogTime:(NSString *)groupId {
-  NSMutableString *query = [NSMutableString stringWithFormat:@"SELECT MIN(\"%@\") FROM \"%@\" WHERE \"%@\" = '%@'", kMSTimestampColumnName,
-                                                             kMSLogTableName, kMSGroupIdColumnName, groupId];
-  NSArray<NSArray *> *entries = [self executeSelectionQuery:query];
-  NSTimeInterval timestamp = 0;
-  if (entries.count > 0 && entries[0].count > 0 && entries[0][0] != [NSNull null]) {
-    NSNumber *logTimestamp = (NSNumber *)entries[0][0];
-    timestamp = [logTimestamp longLongValue] / 1000;
-    NSDate *result = [NSDate dateWithTimeIntervalSince1970:timestamp];
-    return result;
-  }
-  return [NSDate dateWithTimeIntervalSince1970:timestamp];
-}
-
 - (NSArray<id<MSLog>> *)logsFromDBWithGroupId:(NSString *)groupId {
 
   // Get log entries for the given group Id.
diff --git a/AppCenter/AppCenter/Internals/Storage/MSStorage.h b/AppCenter/AppCenter/Internals/Storage/MSStorage.h
index 60b1d2b8c..2dfdfea89 100644
--- a/AppCenter/AppCenter/Internals/Storage/MSStorage.h
+++ b/AppCenter/AppCenter/Internals/Storage/MSStorage.h
@@ -99,14 +99,6 @@ typedef void (^MSLoadDataCompletionHandler)(NSArray<id<MSLog>> *_Nullable logArr
  *
  */
 - (void)setMaxStorageSize:(long)sizeInBytes completionHandler:(nullable void (^)(BOOL))completionHandler;
-
-/**
- * Gets the time of the oldest log.
- *
- * @param groupId The group of the storage for logs.
- * @return The time of the oldest.
- */
-- (NSDate *)getOldestLogTime:(NSString *)groupId;
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/AppCenter/AppCenterTests/MSChannelUnitDefaultTests.m b/AppCenter/AppCenterTests/MSChannelUnitDefaultTests.m
index 72e63458f..ad36d0138 100644
--- a/AppCenter/AppCenterTests/MSChannelUnitDefaultTests.m
+++ b/AppCenter/AppCenterTests/MSChannelUnitDefaultTests.m
@@ -79,6 +79,7 @@ - (void)setUp {
                                                      storage:self.storageMock
                                                configuration:self.configMock
                                            logsDispatchQueue:self.logsDispatchQueue];
+  [MS_USER_DEFAULTS removeObjectForKey:[self.sut getStartTimeKey]];
 
   // Auth token context.
   [MSAuthTokenContext resetSharedInstance];
@@ -89,6 +90,7 @@ - (void)setUp {
 
 - (void)tearDown {
   [MSDispatchTestUtil awaitAndSuspendDispatchQueue:self.logsDispatchQueue];
+  [MS_USER_DEFAULTS removeObjectForKey:[self.sut getStartTimeKey]];
 
   // Stop mocks.
   [self.configMock stopMocking];
@@ -99,6 +101,117 @@ - (void)tearDown {
 
 #pragma mark - Tests
 
+- (void)testResolveFlushIntervalTimestampNotSet {
+  // If
+  __block NSDate *date;
+  id dateMock = OCMClassMock([NSDate class]);
+  NSUInteger flushInterval = 2000;
+
+  // Configure channel.
+  self.sut.configuration = [[MSChannelUnitConfiguration alloc] initWithGroupId:kMSTestGroupId
+                                                                      priority:MSPriorityDefault
+                                                                 flushInterval:flushInterval
+                                                                batchSizeLimit:50
+                                                           pendingBatchesLimit:1];
+  OCMStub(ClassMethod([dateMock date])).andDo(^(NSInvocation *invocation) {
+    date = [[NSDate alloc] initWithTimeIntervalSince1970:1000];
+    [invocation setReturnValue:&date];
+  });
+
+  // When
+  NSUInteger resultFlushInterval = [self.sut resolveFlushInterval];
+
+  // Then
+  XCTAssertEqual(resultFlushInterval, flushInterval);
+
+  // Clear
+  [dateMock stopMocking];
+}
+
+- (void)testResolveFlushIntervalTimestampLaterThanNow {
+  // If
+  __block NSDate *date;
+  id dateMock = OCMClassMock([NSDate class]);
+  NSUInteger flushInterval = 2000;
+
+  // Configure channel.
+  self.sut.configuration = [[MSChannelUnitConfiguration alloc] initWithGroupId:kMSTestGroupId
+                                                                      priority:MSPriorityDefault
+                                                                 flushInterval:flushInterval
+                                                                batchSizeLimit:50
+                                                           pendingBatchesLimit:1];
+  OCMStub(ClassMethod([dateMock date])).andDo(^(NSInvocation *invocation) {
+    date = [[NSDate alloc] initWithTimeIntervalSince1970:1000];
+    [invocation setReturnValue:&date];
+  });
+  [MS_USER_DEFAULTS setObject:[[NSDate alloc] initWithTimeIntervalSince1970:2000] forKey:self.sut.getStartTimeKey];
+
+  // When
+  NSUInteger resultFlushInterval = [self.sut resolveFlushInterval];
+
+  // Then
+  XCTAssertEqual(resultFlushInterval, flushInterval);
+
+  // Clear
+  [dateMock stopMocking];
+}
+
+- (void)testResolveFlushIntervalNow {
+
+  // If
+  __block NSDate *date;
+  id dateMock = OCMClassMock([NSDate class]);
+
+  // Configure channel.
+  self.sut.configuration = [[MSChannelUnitConfiguration alloc] initWithGroupId:kMSTestGroupId
+                                                                      priority:MSPriorityDefault
+                                                                 flushInterval:2000
+                                                                batchSizeLimit:50
+                                                           pendingBatchesLimit:1];
+  OCMStub(ClassMethod([dateMock date])).andDo(^(NSInvocation *invocation) {
+    date = [[NSDate alloc] initWithTimeIntervalSince1970:4000];
+    [invocation setReturnValue:&date];
+  });
+  [MS_USER_DEFAULTS setObject:[[NSDate alloc] initWithTimeIntervalSince1970:2000] forKey:self.sut.getStartTimeKey];
+
+  // When
+  NSUInteger resultFlushInterval = [self.sut resolveFlushInterval];
+
+  // Then
+  XCTAssertEqual(resultFlushInterval, kMSFlushIntervalDefault);
+
+  // Clear
+  [dateMock stopMocking];
+}
+
+- (void)testResolveFlushInterval {
+
+  // If
+  __block NSDate *date;
+  id dateMock = OCMClassMock([NSDate class]);
+
+  // Configure channel.
+  self.sut.configuration = [[MSChannelUnitConfiguration alloc] initWithGroupId:kMSTestGroupId
+                                                                      priority:MSPriorityDefault
+                                                                 flushInterval:2000
+                                                                batchSizeLimit:50
+                                                           pendingBatchesLimit:1];
+  OCMStub(ClassMethod([dateMock date])).andDo(^(NSInvocation *invocation) {
+    date = [[NSDate alloc] initWithTimeIntervalSince1970:1000];
+    [invocation setReturnValue:&date];
+  });
+  [MS_USER_DEFAULTS setObject:[[NSDate alloc] initWithTimeIntervalSince1970:500] forKey:self.sut.getStartTimeKey];
+
+  // When
+  NSUInteger resultFlushInterval = [self.sut resolveFlushInterval];
+
+  // Then
+  XCTAssertEqual(resultFlushInterval, 1500);
+
+  // Clear
+  [dateMock stopMocking];
+}
+
 - (void)testNewInstanceWasInitialisedCorrectly {
   assertThat(self.sut, notNilValue());
   assertThat(self.sut.configuration, equalTo(self.configMock));
diff --git a/AppCenter/AppCenterTests/MSLogDBStorageTests.m b/AppCenter/AppCenterTests/MSLogDBStorageTests.m
index 36a840a16..2455543fa 100644
--- a/AppCenter/AppCenterTests/MSLogDBStorageTests.m
+++ b/AppCenter/AppCenterTests/MSLogDBStorageTests.m
@@ -796,35 +796,6 @@ - (void)testAddNormalLog {
   XCTAssertEqual(criticalLogs.count, 0);
 }
 
-- (void)testGetOldestLogTime {
-  // If
-  NSDate *defaultTime = [NSDate dateWithTimeIntervalSince1970:0];
-
-  // Then
-  NSDate *defaultTimestampResult = [self.sut getOldestLogTime:kMSTestGroupId];
-  XCTAssertEqual(defaultTime.timeIntervalSince1970, defaultTimestampResult.timeIntervalSince1970);
-
-  // If
-  NSDate *firstDate = [NSDate dateWithTimeIntervalSince1970:20];
-  MSAbstractLog *aLog = [MSAbstractLog new];
-  aLog.timestamp = firstDate;
-  NSDate *secondDate = [NSDate dateWithTimeIntervalSince1970:5];
-  MSAbstractLog *aLog2 = [MSAbstractLog new];
-  aLog2.timestamp = secondDate;
-  NSDate *thirdDate = [NSDate dateWithTimeIntervalSince1970:12];
-  MSAbstractLog *aLog3 = [MSAbstractLog new];
-  aLog3.timestamp = thirdDate;
-
-  // When
-  [self.sut saveLog:aLog withGroupId:kMSTestGroupId flags:MSFlagsNormal];
-  [self.sut saveLog:aLog2 withGroupId:kMSTestGroupId flags:MSFlagsNormal];
-  [self.sut saveLog:aLog3 withGroupId:kMSTestGroupId flags:MSFlagsNormal];
-
-  // Then
-  NSDate *oldestLogTimestamp = [self.sut getOldestLogTime:kMSTestGroupId];
-  XCTAssertEqual(secondDate.timeIntervalSince1970, oldestLogTimestamp.timeIntervalSince1970);
-}
-
 - (void)testAddLogsDoesNotExceedCapacity {
 
   // If
diff --git a/AppCenterAuth/MSAL/microsoft-authentication-library-for-objc b/AppCenterAuth/MSAL/microsoft-authentication-library-for-objc
--- a/AppCenterAuth/MSAL/microsoft-authentication-library-for-objc
+++ b/AppCenterAuth/MSAL/microsoft-authentication-library-for-objc
@@ -1 +1 @@
-Subproject commit 2066f07bf5522ac493a6a335955b3dc739638cf0
+Subproject commit 2066f07bf5522ac493a6a335955b3dc739638cf0-dirty
